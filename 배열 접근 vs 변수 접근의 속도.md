# 사건의 발단
코딩테스트를 푸는데, 피보나치 수열을 이용하여 문제를 풀어야 했다. 예전에 배운 다이나믹 프로그래밍을 떠올려 이와 같은 방법으로 접근하였다.
</br>
</br>
1. 길이가 n+1인 dp라는 배열을 선언한다.
2. dp[1] = 1, dp[2] = 2를 저장한다.
3. dp[i] = dp[i-1] + dp[i-2] where i is 3 to n-1
4. dp[n]을 리턴한다.
</br>
</br>

코드 1
</br>
<img src="/image/2코드.JPG">
</br>
</br>
누가 봐도 피보나치의 정석 그 자체였다.
그런데, 다음과 같은 문제가 발생했다.
</br>
</br>
결과 1
<img src="/image/2결과.JPG">
</br>
</br>
분명 테스트 케이스는 통과했는데, 효율성 테스트는 처참하게 실패하였다. 
왜 일까? 이 방법은 메모이제이션을 이용하여 속도가 훨씬 빠르다고 들었었는데.....
</br>
</br>
그러던 도중, 처음 피보나치 수열을 배웠을 때를 떠올리고 단 3개의 변수로 다시 풀어보았다.
</br>
</br>
코드2
</br>
<img src="/image/3코드.JPG">
</br>
</br>
정말 놀랍게도, 결과가 달랐다.

결과2
</br>
</br>
<img src="/image/3효율.JPG">

신기하게도 테스트1의 결과를 보면,

변수로 푼 속도(5ms)가 배열로 푼 속도(21ms)보다 약 4배 정도 빨랐다.

또한 사용한 공간도 2배 정도 적었다.

공간은 납득 할 수 있었다. 당연히 배열은 n+1의 길이만큼 선언하여 사용하고, 변수는 3개의 변수만 사용하니깐. 그런데 속도는 이해를 할 수 없었다. 
</br>
</br>
## 뇌피셜
1. 분명 저 둘은 같은 횟수로 반복한다. 배열에서는 3 to n, 배열에서는 0 to n-3 이므로 둘 다 n-2회 반복한다.
2. 또한 배열이나 변수나 모두 런타임때 메모리에 존재하므로 같은 접근 시간을 가질 것이다. 
3. 따라서 둘의 시간이 다를 이유가 없다.

</br>
</br>
</br>

## 생각

분명 무언가 다르니깐 결과가 다른 것이다. 이때, 어셈블리 수업을 들었을 때가 생각났다. 코드상으로는 비슷해 보이지만, 어셈블리어로 내려왔을 때 두 코드가 달라질 것이다.
두 코드를 어셈블리어로 바꿔보자. 

## 시도1 어셈블리어 변환
</br>
</br>

### 배열을 사용한 파이썬 코드
<img src="/image/a1.JPG">

</br>
</br>

### 어셈블리어로 변환된 코드
<img src="/image/a11.JPG">

</br>
</br>
</br>
</br>

## 시도 2 어셈블리어 변환
</br>
</br>

### 변수를 사용한 파이썬 코드
<img src="/image/a22.JPG">

</br>
</br>

### 어셈블리어로 변환된 코드
<img src="/image/a222.JPG">

</br>
</br>


</br>

</br>


## 결과
단순히 어셈블리어 코드의 길이만 봐도 배열을 사용한 코드가 2배 정도 길다. 즉 연산이 더 오래 걸린다.

파이썬 코드상으로는 시도1이 더 빠르거나 같은 속도로 연산을 할 것 처럼 보인다. 하지만, 어셈블리의 측면에서 볼 때, 배열은 레지스터가 아닌 메모리에 위치하므로 배열 접근을 위한 시간 소모가 훨씬 크기 때문에 위와 같은 결과를 가져온 것이다. 

즉 보이는 것이 다가 아니다.

## 고찰해야 할 점(나중에 채우기)

항상 이러한 디테일을 생각했어야 했는데 그러질 못하였다.

1. 코드 실행 시 코드가 어떻게 메모리에 적재되는지
2. 코드 실행 시 코드의 변수들이 어떻게 레지스터에 적재되는지
3. 필요 CS 지식 : 어셈블리어, 컴퓨터구조  
